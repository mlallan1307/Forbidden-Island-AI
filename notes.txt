===========================
=        Outline
===========================

Classes:
***Game_Board()
tracks the locations of the 24 tiles and their status (dry, flooded, sunk)
Includes a 'shuffle' method to generate a random layout for each game
Includes a 'flip' method for flooding / shoring_up a tile
includes a 'sink' method for removing a tile from the game
A data structure  (I think it would be a dictionary in Python) for tile information:
--ID (zero thru 23)
--Name
--Associated_Treasure (if any)
--Associated_Adventure (if any)
####
We could build a Tile class and let the Game_Board track 24 Tile objects, but not sure which approach would be more complex


****Flood_Deck()
Contains the 24 flood cards
Each card is either:
-- in the deck (with a position)
-- in the discard pile
--- removed from the
Includes a 'shuffle' method for initial setup
Includes a 'draw' method for flipping a card (reshuffle deck if empty)
Includes a 'sink' method for removing that card if the associated tile is sunk
Includes a 'waters rise' method for shuffling the discard pile and placing it on top of the deck
####
Not exactly sure where to place the code for having players escape to safety (or lose the game) when their tile is sunk.  My initial guess is to have the Board drive the 'sink' action and tell the Flood_Deck to sink the matching card.

***Treasure_Deck()
Contains the 28 treasure cards
Each card is either:
-- in the deck (with a position)
-- in the discard pile
-- in a player's hand
Includes a 'shuffle' method for initial setup
Includes a 'draw' method for assigning the top card to a player (reshuffle if deck is empty)
Includes a 'give' method for moving the card from one player to another
includes a 'play' method for executing cards and placing them to discard.

***Player()
Tracks Adventurer type and location of player on board and any treasures being carried
Has method's for:
--tracking treasure cards in hand
--can_move (lists possible movement destinations, taking special movement abilities into account)
--move
--can_shore_up (lists underwater tiles that player can shore up from current location, or from a passed-in location)
--shore_up
--give_card (probably doesn't need a 'can' method, just some error checking in case the A.I tries something illegal)
--capture_treasure (need 4 of a kind in hand and be on matching tile)
--draw_card (checks for hand limit; may use a special card to free up space)
--play_special_card (complex logic here)
<<surely forgetting something>>
####
I think the easiest approach would be to build 6 one-off Player classes (one for each adventurer type) and hard-code their additional abilities (diver movement, engineer shore_up, messenger card_giving, etc.).  The game instance can randomly create 2 to 4 player instances during initialization.


***Forbidden_Island(num_players, difficulty)
Tracks Water Level
Checks for game won / Game lost
Initializes a game
--build Board instance
--build Flood_Deck instance
--draw 6 Flood_Deck cards and 'flip' matching tiles on the board
--build 2-4 Player instances
--build Treasure_Deck instance
--each Player draws 2 treasure cards
Drives the turns with a while loop
Tracks special circumstances  or "interrupts" such as a player having to escape from a tile that just sunk.



New Notes added 30 OCT
ChangeLog 30 OCT

In summary: Game is barely playable by a human.

Play_Game() now asks human to choose from avaiable actions
Passing (skip an action) works, though it could be more elegant
Moving Orthagonally from tile to tile seems solid
Giving non-special cards to other players in same tile seems solid
Capturing treasures worked under a couple of quick tests

Hand limit is not enforced, and game crashes when Treasure_Deck is empty
    (due to cards being in player's hands).  
    Use 2 player gane to have a good chance of capturing a treasure 
    (and discard 4 cards) before Treasure_Deck empties out.


Not crazy about Player locations being doubly-tracked by tiles in BOARD and by player objects,
    but seems solid.

=============================================
Refactored BOARD into a non-global object.

1.  Forbidden_Island() generates a new BOARD

2.  pass BOARD to Flood_Deck(BOARD) to conduct sink actions

3.  pass BOARD to player(player_num, adventurers, treasure_deck, BOARD) to manipulate 
    player positions, Moves, Shore_Ups, Give_Cards, and Captures

4.  print_game needs to use 'game.BOARD' in lieu of 'BOARD'

============================================
Commented out the discard([cards]) method from Treasure_Deck, because
   we never discard multiple cards, and it caused a name conflict with 
   the discard pile (self.discard[])

============================================
Player.can_move() now returns only the next available move instead of 3 available moves
   Old code was commented out and can be reinstated easily
   I think one move at a time is better, or else we'd have to include many permutations of
      move + shore_up + give_card + capture
Player.__repr__ returns "Player #" in case player is referenced as a string
Player.capture_treasure() now calls treasure_deck.discard([card]) instead of (card) (sends a list)
Player.can_give_card() now returns card objects instead of card indexes
   Indexes don't map well to sorted hand list in print_game(game)

=============================================
Added currentPlayer to Forbidden_Island object to track current player
Added actionsRemaining to Forbidden_Island to track number of actions remaining
Added nextPlayer() to Forbidden_Island to increment currentPlayer to 
   next player and reset actionsRemaining to 3
Added gameOver = False to Forbidden_Island to triggerEndgame

=============================================
print_game(game) now shows "Acitons Remaining: #" next to current player's card listing

=============================================
Commented out some code AI() & added 1 line so that it now expects only the next available move.
   (this matches the current implementation of Player.can_move)


=============================================
Play game now takes numPlayers and difficulty and passes them to the Forbidden Island game 
Added While(gameOver == False)  Loop from e-mail to play_game()
Added an playerInput[] to play_game().
   This list contains one method for each player in the game (so each player can be controlled
      by a human, by a seperate AI, or by the same AI.
   On each player's turn, their corresponding method is called and passed a reference to the
      Forbidden_Island game.  The called method (assisted by getActions) returns a tuple 
      describing the chosen action

============================================
Created getActions(game)
   Returns a list containing a tuple for each possible currently possible (no look-ahead)

Created getHumanInput(game)
   calls getActions(), enumerates & lists the actions, and asks human to choose one

Created performAction(action, game)
   Performs the passed action on the game


///////////// Still To Do (incomplete list) //////////
* Playing Special cards - ?Make this an option that is always on the actions list?
                          Allow any player to play any other player's special card.
                          Also call this this when forced to discard.

* "Waters Rise" card - still no effect.  Also test tiles sinking.

* Enfore Hand Limits on Treasure Cards

* "Escape Sunk Tile" interrupt that lets a player escape when their tile is sunk.

* Set 'gameOver = True' Conditions-  Fool's Landing is Sunk
                                     Both tiles of an unclaimed treasure are sunk
                                     A character can't escape a sunk tile
                                     Water Level == 10

* Add a 'Pass' Action

* BUG: When tiles start sinking, the remaining tiles in print_game start are renumbered
       so that no numbers are skipped.  This causes the tiles listed in Actions to not
       match the display.  Recommend modifying print_game(game) to not re-number tiles.
