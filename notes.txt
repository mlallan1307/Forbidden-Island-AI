===========================
=        Outline
===========================

Classes:
***Game_Board()
tracks the locations of the 24 tiles and their status (dry, flooded, sunk)
Includes a 'shuffle' method to generate a random layout for each game
Includes a 'flip' method for flooding / shoring_up a tile
includes a 'sink' method for removing a tile from the game
A data structure  (I think it would be a dictionary in Python) for tile information:
--ID (zero thru 23)
--Name
--Associated_Treasure (if any)
--Associated_Adventure (if any)
####
We could build a Tile class and let the Game_Board track 24 Tile objects, but not sure which approach would be more complex


****Flood_Deck()
Contains the 24 flood cards
Each card is either:
-- in the deck (with a position)
-- in the discard pile
--- removed from the
Includes a 'shuffle' method for initial setup
Includes a 'draw' method for flipping a card (reshuffle deck if empty)
Includes a 'sink' method for removing that card if the associated tile is sunk
Includes a 'waters rise' method for shuffling the discard pile and placing it on top of the deck
####
Not exactly sure where to place the code for having players escape to safety (or lose the game) when their tile is sunk.  My initial guess is to have the Board drive the 'sink' action and tell the Flood_Deck to sink the matching card.

***Treasure_Deck()
Contains the 28 treasure cards
Each card is either:
-- in the deck (with a position)
-- in the discard pile
-- in a player's hand
Includes a 'shuffle' method for initial setup
Includes a 'draw' method for assigning the top card to a player (reshuffle if deck is empty)
Includes a 'give' method for moving the card from one player to another
includes a 'play' method for executing cards and placing them to discard.

***Player()
Tracks Adventurer type and location of player on board and any treasures being carried
Has method's for:
--tracking treasure cards in hand
--can_move (lists possible movement destinations, taking special movement abilities into account)
--move
--can_shore_up (lists underwater tiles that player can shore up from current location, or from a passed-in location)
--shore_up
--give_card (probably doesn't need a 'can' method, just some error checking in case the A.I tries something illegal)
--capture_treasure (need 4 of a kind in hand and be on matching tile)
--draw_card (checks for hand limit; may use a special card to free up space)
--play_special_card (complex logic here)
<<surely forgetting something>>
####
I think the easiest approach would be to build 6 one-off Player classes (one for each adventurer type) and hard-code their additional abilities (diver movement, engineer shore_up, messenger card_giving, etc.).  The game instance can randomly create 2 to 4 player instances during initialization.


***Forbidden_Island(num_players, difficulty)
Tracks Water Level
Checks for game won / Game lost
Initializes a game
--build Board instance
--build Flood_Deck instance
--draw 6 Flood_Deck cards and 'flip' matching tiles on the board
--build 2-4 Player instances
--build Treasure_Deck instance
--each Player draws 2 treasure cards
Drives the turns with a while loop
Tracks special circumstances  or "interrupts" such as a player having to escape from a tile that just sunk.
